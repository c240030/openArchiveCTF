import math
from Crypto.Util.number import long_to_bytes, inverse

# A function to implement the Extended Euclidean Algorithm
def extended_gcd(a, b):
    """
    Returns (gcd, x, y) such that a*x + b*y = gcd
    """
    if a == 0:
        return (b, 0, 1)
    else:
        gcd, x, y = extended_gcd(b % a, a)
        return (gcd, y - (b // a) * x, x)

# The values from the challenge output
N = 13172635138210286640933237746072073728198869440440273861514688422430115450596963502627269613634657978751692320585777768877613321668778514462972611542147278205792418292362109100597755668571861738781190210255903465162483813897653948305531342676537057130369323555420200545974179860718822410192595079238246216026529376260568656408216009127973127738250617629330070723654601189310430802429585919291621479622419163092371272056180409609142738265178224163465585013019636286435078812898907472859171136422659050412212315590509027225331104292443193693974638004592849794819591007103879538185323581422819852185166422985403024630123
ct1 = 8499526321488266762028127474977263983474334713646962923180757984708039537289636737028409522654349845032612940144246996001396064450188534247830979105036627472087587636695469693411422088223080856169980341928057477564688506588678465277896123712776169270866525885072607021419929184184301722442524104467963680432737243478200661224741027413690099507128782156810842444314483076587935222998920241102484844741597333281611874849648935849985954902264102662618041817365284648356127737145896858259709819593359264714426125676691235985164360773645489923563993927995838346085066937602961724919392025887999986486672200850129835569774
ct2 = 2263178005282615069738169250508811825030372342139636879043114251227029802177975391784856426659871916802959302578620910469427367218786299839311310420522660987052055310279591316813828952756984548230575321772825193775083404279028090110850848262192595930920326368607665856808251531130234210906413358662814500632504899088517752958423466186872534450108628371006268110210630017230741670440780982809417986017372337888735465439382827207990030719121834402226087906249993820193417658352914727984318783025375497623944699995700474418221251293446038111913247755996471673024017921092527032486774115935601292346440934530921157935322

# Exponents
e1 = 65537
e2 = N + 1

print("[+] Applying Common Modulus Attack")
print(f"[+] e1 = {e1}")
print(f"[+] e2 = N + 1")

# Step 1: Use Extended Euclidean Algorithm to find a, b such that a*e1 + b*e2 = 1
gcd, a, b = extended_gcd(e1, e2)

if gcd != 1:
    print("[-] GCD is not 1, cannot proceed.")
    exit()

print("[+] Found coefficients a and b for the attack.")
# Note: One of a or b will be negative.

# Step 2: Decrypt the message
# m = (ct1^a) * (ct2^b) mod N
# We need to handle the negative exponent carefully.
# If an exponent `x` is negative, c^x = (c^-1)^(-x) = (inverse(c, N))^(-x)

if a < 0:
    c1_a = pow(inverse(ct1, N), -a, N)
else:
    c1_a = pow(ct1, a, N)

if b < 0:
    c2_b = pow(inverse(ct2, N), -b, N)
else:
    c2_b = pow(ct2, b, N)

m = (c1_a * c2_b) % N

# Step 3: Convert the message number back to bytes
flag = long_to_bytes(m)

print("\n" + "="*50)
print(f"[*] The flag is: {flag.decode()}")
print("="*50)